"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.where = where;
const Firestore = require('@google-cloud/firestore');

const {
    GC_PRIVATE_KEY,
    GC_CLIENT_EMAIL,
    GC_PROJECT
} = process.env;

if (GC_PROJECT && GC_CLIENT_EMAIL && GC_CLIENT_KEY) ;else throw new Error(`\
    Goggle-Cloud login information not set in env!
    Need GC_PROJECT, GC_CLIENT_EMAIL and GC_CLIENT_KEY.\
`);

const COMPARISONS = {
    equals: "==",
    lessthan: "<",
    morethan: ">",
    notless: ">=",
    notmore: "<="
};

const PARSE_QUERY = /^(\w+?)\.(\w+)(?: *(==|>|<|>=|<=) *(\S+))?$/;

const firestore = exports.firestore = new Firestore({
    projectID: GC_PROJECT,
    credencials: {
        client_email: GC_CLIENT_EMAIL,
        client_key: GC_PRIVATE_KEY.replace(/\\n/g, '\n')
    }
});

async function find(search, against, asserting, onValue) {
    const found = await firestore.collection(search).where(against, asserting, onValue).get();
    const item = found.docs[0];
    if (item) return item.data();else return false;
}

function where(query) {

    const parse = Array.from(PARSE_QUERY.exec(query) || []).filter(capture => capture !== undefined);

    switch (parse.length) {
        case 3:
            {
                const opts = {};
                for (const comp in COMPARISONS) opts[comp] = value => {
                    if (value === "undefined") throw new Error("No value provided to comparitor for firestore query!");
                    return find(parse[1], parse[2], COMPARISONS[comp], value);
                };
                return opts;
            }
        case 5:
            return find.apply(null, parse.slice(1));
        default:
            throw new Error("Bad Arguments");
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maXJlc3RvcmUuanMiXSwibmFtZXMiOlsid2hlcmUiLCJGaXJlc3RvcmUiLCJyZXF1aXJlIiwiR0NfUFJJVkFURV9LRVkiLCJHQ19DTElFTlRfRU1BSUwiLCJHQ19QUk9KRUNUIiwicHJvY2VzcyIsImVudiIsIkdDX0NMSUVOVF9LRVkiLCJFcnJvciIsIkNPTVBBUklTT05TIiwiZXF1YWxzIiwibGVzc3RoYW4iLCJtb3JldGhhbiIsIm5vdGxlc3MiLCJub3Rtb3JlIiwiUEFSU0VfUVVFUlkiLCJmaXJlc3RvcmUiLCJwcm9qZWN0SUQiLCJjcmVkZW5jaWFscyIsImNsaWVudF9lbWFpbCIsImNsaWVudF9rZXkiLCJyZXBsYWNlIiwiZmluZCIsInNlYXJjaCIsImFnYWluc3QiLCJhc3NlcnRpbmciLCJvblZhbHVlIiwiZm91bmQiLCJjb2xsZWN0aW9uIiwiZ2V0IiwiaXRlbSIsImRvY3MiLCJkYXRhIiwicXVlcnkiLCJwYXJzZSIsIkFycmF5IiwiZnJvbSIsImV4ZWMiLCJmaWx0ZXIiLCJjYXB0dXJlIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwib3B0cyIsImNvbXAiLCJ2YWx1ZSIsImFwcGx5Iiwic2xpY2UiXSwibWFwcGluZ3MiOiI7Ozs7O1FBdUNnQkEsSyxHQUFBQSxLO0FBdkNoQixNQUFNQyxZQUFZQyxRQUFRLHlCQUFSLENBQWxCOztBQUVBLE1BQU07QUFDRkMsa0JBREU7QUFFRkMsbUJBRkU7QUFHRkM7QUFIRSxJQUlGQyxRQUFRQyxHQUpaOztBQU1BLElBQUdGLGNBQWNELGVBQWQsSUFBaUNJLGFBQXBDLEVBQWtELENBQWxELEtBQ0ssTUFBTSxJQUFJQyxLQUFKLENBQVc7OztDQUFYLENBQU47O0FBS0wsTUFBTUMsY0FBYztBQUNoQkMsWUFBUSxJQURRO0FBRWhCQyxjQUFVLEdBRk07QUFHaEJDLGNBQVUsR0FITTtBQUloQkMsYUFBUyxJQUpPO0FBS2hCQyxhQUFTO0FBTE8sQ0FBcEI7O0FBUUEsTUFBTUMsY0FBYyw2Q0FBcEI7O0FBRU8sTUFBTUMsZ0NBQVksSUFBSWhCLFNBQUosQ0FBYztBQUNuQ2lCLGVBQVdiLFVBRHdCO0FBRW5DYyxpQkFBYTtBQUNUQyxzQkFBY2hCLGVBREw7QUFFVGlCLG9CQUFZbEIsZUFBZW1CLE9BQWYsQ0FBdUIsTUFBdkIsRUFBK0IsSUFBL0I7QUFGSDtBQUZzQixDQUFkLENBQWxCOztBQVFQLGVBQWVDLElBQWYsQ0FBb0JDLE1BQXBCLEVBQTRCQyxPQUE1QixFQUFxQ0MsU0FBckMsRUFBZ0RDLE9BQWhELEVBQXdEO0FBQ3BELFVBQU1DLFFBQVEsTUFBTVgsVUFBVVksVUFBVixDQUFxQkwsTUFBckIsRUFBNkJ4QixLQUE3QixDQUFtQ3lCLE9BQW5DLEVBQTRDQyxTQUE1QyxFQUF1REMsT0FBdkQsRUFBZ0VHLEdBQWhFLEVBQXBCO0FBQ0EsVUFBTUMsT0FBT0gsTUFBTUksSUFBTixDQUFXLENBQVgsQ0FBYjtBQUNBLFFBQUdELElBQUgsRUFBUyxPQUFPQSxLQUFLRSxJQUFMLEVBQVAsQ0FBVCxLQUNLLE9BQU8sS0FBUDtBQUNSOztBQUVNLFNBQVNqQyxLQUFULENBQWVrQyxLQUFmLEVBQXFCOztBQUV4QixVQUFNQyxRQUFRQyxNQUNUQyxJQURTLENBQ0pyQixZQUFZc0IsSUFBWixDQUFpQkosS0FBakIsS0FBMkIsRUFEdkIsRUFFVEssTUFGUyxDQUVGQyxXQUFXQSxZQUFZQyxTQUZyQixDQUFkOztBQUlBLFlBQU9OLE1BQU1PLE1BQWI7QUFDSSxhQUFLLENBQUw7QUFBUTtBQUNKLHNCQUFNQyxPQUFPLEVBQWI7QUFDQSxxQkFBSSxNQUFNQyxJQUFWLElBQWtCbEMsV0FBbEIsRUFDSWlDLEtBQUtDLElBQUwsSUFBYUMsU0FBUztBQUNsQix3QkFBR0EsVUFBVSxXQUFiLEVBQ0ksTUFBTSxJQUFJcEMsS0FBSixDQUFVLHNEQUFWLENBQU47QUFDSiwyQkFBT2MsS0FBS1ksTUFBTSxDQUFOLENBQUwsRUFBZUEsTUFBTSxDQUFOLENBQWYsRUFBeUJ6QixZQUFZa0MsSUFBWixDQUF6QixFQUE0Q0MsS0FBNUMsQ0FBUDtBQUNILGlCQUpEO0FBS0osdUJBQU9GLElBQVA7QUFDSDtBQUNELGFBQUssQ0FBTDtBQUNJLG1CQUFPcEIsS0FBS3VCLEtBQUwsQ0FBVyxJQUFYLEVBQWlCWCxNQUFNWSxLQUFOLENBQVksQ0FBWixDQUFqQixDQUFQO0FBQ0o7QUFDSSxrQkFBTSxJQUFJdEMsS0FBSixDQUFVLGVBQVYsQ0FBTjtBQWRSO0FBZ0JIIiwiZmlsZSI6ImZpcmVzdG9yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEZpcmVzdG9yZSA9IHJlcXVpcmUoJ0Bnb29nbGUtY2xvdWQvZmlyZXN0b3JlJyk7XG5cbmNvbnN0IHtcbiAgICBHQ19QUklWQVRFX0tFWSxcbiAgICBHQ19DTElFTlRfRU1BSUwsXG4gICAgR0NfUFJPSkVDVFxufSA9IHByb2Nlc3MuZW52O1xuXG5pZihHQ19QUk9KRUNUICYmIEdDX0NMSUVOVF9FTUFJTCAmJiBHQ19DTElFTlRfS0VZKTtcbmVsc2UgdGhyb3cgbmV3IEVycm9yKGBcXFxuICAgIEdvZ2dsZS1DbG91ZCBsb2dpbiBpbmZvcm1hdGlvbiBub3Qgc2V0IGluIGVudiFcbiAgICBOZWVkIEdDX1BST0pFQ1QsIEdDX0NMSUVOVF9FTUFJTCBhbmQgR0NfQ0xJRU5UX0tFWS5cXFxuYClcblxuY29uc3QgQ09NUEFSSVNPTlMgPSB7XG4gICAgZXF1YWxzOiBcIj09XCIsXG4gICAgbGVzc3RoYW46IFwiPFwiLFxuICAgIG1vcmV0aGFuOiBcIj5cIixcbiAgICBub3RsZXNzOiBcIj49XCIsXG4gICAgbm90bW9yZTogXCI8PVwiXG59XG5cbmNvbnN0IFBBUlNFX1FVRVJZID0gL14oXFx3Kz8pXFwuKFxcdyspKD86ICooPT18Pnw8fD49fDw9KSAqKFxcUyspKT8kLztcblxuZXhwb3J0IGNvbnN0IGZpcmVzdG9yZSA9IG5ldyBGaXJlc3RvcmUoe1xuICAgIHByb2plY3RJRDogR0NfUFJPSkVDVCxcbiAgICBjcmVkZW5jaWFsczoge1xuICAgICAgICBjbGllbnRfZW1haWw6IEdDX0NMSUVOVF9FTUFJTCxcbiAgICAgICAgY2xpZW50X2tleTogR0NfUFJJVkFURV9LRVkucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgfVxufSlcblxuYXN5bmMgZnVuY3Rpb24gZmluZChzZWFyY2gsIGFnYWluc3QsIGFzc2VydGluZywgb25WYWx1ZSl7XG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCBmaXJlc3RvcmUuY29sbGVjdGlvbihzZWFyY2gpLndoZXJlKGFnYWluc3QsIGFzc2VydGluZywgb25WYWx1ZSkuZ2V0KCk7XG4gICAgY29uc3QgaXRlbSA9IGZvdW5kLmRvY3NbMF07XG4gICAgaWYoaXRlbSkgcmV0dXJuIGl0ZW0uZGF0YSgpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlcmUocXVlcnkpe1xuXG4gICAgY29uc3QgcGFyc2UgPSBBcnJheVxuICAgICAgICAuZnJvbShQQVJTRV9RVUVSWS5leGVjKHF1ZXJ5KSB8fCBbXSlcbiAgICAgICAgLmZpbHRlcihjYXB0dXJlID0+IGNhcHR1cmUgIT09IHVuZGVmaW5lZClcblxuICAgIHN3aXRjaChwYXJzZS5sZW5ndGgpe1xuICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgICAgIGZvcihjb25zdCBjb21wIGluIENPTVBBUklTT05TKVxuICAgICAgICAgICAgICAgIG9wdHNbY29tcF0gPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgcHJvdmlkZWQgdG8gY29tcGFyaXRvciBmb3IgZmlyZXN0b3JlIHF1ZXJ5IVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZChwYXJzZVsxXSwgcGFyc2VbMl0sIENPTVBBUklTT05TW2NvbXBdLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZmluZC5hcHBseShudWxsLCBwYXJzZS5zbGljZSgxKSlcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBBcmd1bWVudHNcIilcbiAgICB9XG59Il19